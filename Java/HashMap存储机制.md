# Hashmap存储机制

哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表。

- 什么是哈希表
- Hashmap实现原理
- 为什么Hashmap的数组长度一定是2的次幂
- 重写equals方法需同时重写hashCode方法

## 哈希表

先大概了解数据结构在基础操作上的执行性能

- **数组**：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)
- **线性链表**：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)
- **二叉树**：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。
- **哈希表**：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。

在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，哈希表的**主干就是数组**。我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作，这函数就是**哈希函数**。

### 1. 常见的hash算法

1. **直接定址法**：直接以关键字k或者k加上某个常数（k+c）作为哈希地址（H(k)=ak+b）。
2. **数字分析法**：提取关键字中取值比较均匀的数字作为哈希地址（如一组出生日期，相较于年-月，月-日的差别要大得多，可以降低冲突概率）
3. **分段叠加法**：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。
4. **平方取中法**：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。
5. **伪随机数法**：选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。
6. **除留余数法**：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址（H(k)=k%p, p<=m; p一般取m或素数）。

### 哈希冲突

如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？

### Hash算法解决冲突的方法

**开放定址法**：所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入 公式为：fi(key) = (f(key)+di) MOD m (di=1,2,3,……,m-1)

1. **线性探测** 
   以增量序列 1，2，……，（TableSize -1）循环试探下一个存储地址，即di = i。如果table[index+di]为空则进行插入，反之试探下一个增量。但是线性探测也有弊端，就是会造成元素聚集现象，降低查找效率。

![](https://github.com/shenjiahuihm/note/blob/master/imgs/Java/线性探测.png))

**特别对于开放定址法的删除操作，不能简单的进行物理删除，因为对于同义词来说，这个地址可能在其查找路径上，若物理删除的话，会中断查找路径，故只能设置删除标志。**

2. **平方探测** 

   以增量序列1，-1，4，-4…且q ≤ TableSize/2 循环试探下一个存储地址。

3. **双散列探测** 

   di 为i*h2(key)，h2(key)是另一个散列函数。探测序列成：h2(key)，2h2(key)，3h2(key)，……。对任意的key，h2(key) ≠ 0 ！探测序列还应该保证所有的散列存储单元都应该能够被探测到。选择以下形式有良好的效果： 
   h2(key) = p - (key mod p) 
   其中：p < TableSize，p、TableSize都是素数。

**再哈希法**：