## Synchronized

- synchronized关键字是通过字节码指令来实现的
- synchronized关键字编译后会在同步块前后形成monitorenter和monitorexit两个字节码指令
- 执行monitorenter指令时需要先获得对象的锁（每个对象有一个监视器锁monitor），如果这个对象没被锁或者当前线程已经获得此锁（也就是重入锁），那么锁的计数器+1。如果获取失败，那么当前线程阻塞，直到锁被对另一个线程释放
- 执行monitorexit指令时，计数器减一，当为0的时候锁释放

## volatile

#### 作用

- 保证变量对所有的线程的可见性，当一个线程修改了这个变量的值，其他线程可以立即知道这个新值（之所以有可见性的问题，是因为java的内存模型）

#### 原理

- 所有变量都存在主内存，每条线程有自己的工作内存，工作内存保存了被该线程使用的变量的主内存副本拷贝
- 线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存的变量，也就是必须先通过工作内存
- 一个线程不能访问另一个线程的工作内存
- volatile保证了变量更新的时候能够立即同步到主内存，使用变量的时候能立即从主内存刷新到工作内存，这样就保证了变量的可见性
- 实际上是通过内存屏障来实现的。语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。

![](https://github.com/shenjiahuihm/note/blob/master/imgs/Java/volatile.png)

## Atomic

#### 作用

- 当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以像自旋锁一样，继续尝试，一直等到执行成功。
- CAS操作（compare and swap 对比和设置），是通过一个cpu指令实现的，这个指令是一个原子指令，指令有3个操作数ABC，A为内存位置，B为预期值，C为新值，如果A符合旧预期值B，那么用V更新A的值，如果不符合就不更新，这个过程是原子操作