## Synchronized

- synchronized关键字是通过字节码指令来实现的
- synchronized关键字编译后会在同步块前后形成monitorenter和monitorexit两个字节码指令
- 执行monitorenter指令时需要先获得对象的锁（每个对象有一个监视器锁monitor），如果这个对象没被锁或者当前线程已经获得此锁（也就是重入锁），那么锁的计数器+1。如果获取失败，那么当前线程阻塞，直到锁被对另一个线程释放
- 执行monitorexit指令时，计数器减一，当为0的时候锁释放

## volatile

#### 作用

- 保证变量对所有的线程的可见性，当一个线程修改了这个变量的值，其他线程可以立即知道这个新值（之所以有可见性的问题，是因为java的内存模型）

#### 原理

- 所有变量都存在主内存，每条线程有自己的工作内存，工作内存保存了被该线程使用的变量的主内存副本拷贝
- 线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存的变量，也就是必须先通过工作内存
- 一个线程不能访问另一个线程的工作内存
- volatile保证了变量更新的时候能够立即同步到主内存，使用变量的时候能立即从主内存刷新到工作内存，这样就保证了变量的可见性
- 实际上是通过内存屏障来实现的。语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。

![](https://github.com/shenjiahuihm/note/blob/master/imgs/Java/volatile.png)

计算机在运行程序时，每条指令都是在CPU中执行的，在执行过程中势必会涉及到数据的读写。我们知道程序运行的数据是存储在主存中，这时就会有一个问题，读写主存中的数据没有CPU中执行指令的速度快，如果任何的交互都需要与主存打交道则会大大影响效率，所以就有了CPU高速缓存。CPU高速缓存为某个CPU独有，只与在该CPU运行的线程有关。

有了CPU高速缓存虽然解决了效率问题，但是它会带来一个新的问题：数据一致性。在程序运行中，会将运行所需要的数据复制一份到CPU高速缓存中，在进行运算时CPU不再也主存打交道，而是直接从高速缓存中读写数据，只有当运行结束后才会将数据刷新到主存中。举一个简单的例子：

```
i++i++
```

当线程运行这段代码时，首先会从主存中读取i( i = 1)，然后复制一份到CPU高速缓存中，然后CPU执行 + 1 （2）的操作，然后将数据（2）写入到告诉缓存中，最后刷新到主存中。其实这样做在单线程中是没有问题的，有问题的是在多线程中。如下：

假如有两个线程A、B都执行这个操作（i++），按照我们正常的逻辑思维主存中的i值应该=3，但事实是这样么？分析如下：

两个线程从主存中读取i的值（1）到各自的高速缓存中，然后线程A执行+1操作并将结果写入高速缓存中，最后写入主存中，此时主存i==2,线程B做同样的操作，主存中的i仍然=2。所以最终结果为2并不是3。这种现象就是缓存一致性问题。

解决缓存一致性方案有两种：

1. 通过在总线加LOCK#锁的方式
2. 通过缓存一致性协议

但是方案1存在一个问题，它是采用一种独占的方式来实现的，即总线加LOCK#锁的话，只能有一个CPU能够运行，其他CPU都得阻塞，效率较为低下。

第二种方案，缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。其核心思想如下：当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。

在执行程序时为了提高性能，编译器和处理器通常会对指令做重排序：

1. 编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；
2. 处理器重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；

观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。lock前缀指令其实就相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。volatile的底层就是通过内存屏障来实现的。下图是完成上述规则所需要的内存屏障：

## Atomic

#### 作用

- 当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以像自旋锁一样，继续尝试，一直等到执行成功。
- CAS操作（compare and swap 对比和设置），是通过一个cpu指令实现的，这个指令是一个原子指令，指令有3个操作数ABC，A为内存位置，B为预期值，C为新值，如果A符合旧预期值B，那么用V更新A的值，如果不符合就不更新，这个过程是原子操作