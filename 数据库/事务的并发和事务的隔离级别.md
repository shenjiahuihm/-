# 事务并发可能产生的问题

## 脏读

- 当一个事务读取到另外一个事务修改但未提交的数据时，就可能发生脏读

## 不可重复读

- 事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。

## 幻读

- 和不可重复度一样，都是读到其他事务已提交的数据
- 不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。 　　

# 事务的隔离级别

| 事务隔离级别                                                 | 脏读 | 不可重复读 | 幻读 |
| :----------------------------------------------------------- | :--- | :--------- | :--- |
| 未提交读 read-uncommitted                                    | 是   | 是         | 是   |
| 已提交读 read-committed                                      | 否   | 是         | 是   |
| 可重复读 repeatable-read                                     | 否   | 否         | 是   |
| 串行化 serializable                                          | 否   | 否         | 否   |
|                                                              |      |            |      |
| **未提交读**：如果一个事务已经开始写数据，则另外一个事务则**不允许同时进行写操作，但允许其他事读此行数据**。脏读 |      |            |      |
| **已提交读**：读取数据的事务**允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行，会对该写锁一直保持直到事务提交**。能解决脏读，却防不了不可重复读。 |      |            |      |
| **可重复读**：在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有**幻读**现象 |      |            |      |
| **串行化**：最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样 |      |            |      |
|                                                              |      |            |      |
| **MySQL默认的事务隔离级别为repeatable-read**                 |      |            |      |