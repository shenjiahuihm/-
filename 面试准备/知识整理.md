### Java基础

### 数据结构和算法

### JVM

### 多线程

1. synchronized和ReentrantLock的区别

   #### 功能区别

   **基本意义**：Synchronized是Java语言的关键字，因此Synchronized的锁是原生语法层面的互斥，需要JVM来实现。具体是通过对象内部的一个叫做监视器锁（monitor）来实现的。ReentrantLock，字面意思可重入锁，它是JDK1.5之后提供的API层面的互斥锁，锁的功能主要由2个方法完成，即lock()和unlock()。**易用性**：Synchronized的使用比较方便简洁，由编译器去保证锁的加锁和释放，而ReentrantLock需要手动写代码来加锁和释放锁。
   注意：为避免忘记手工释放锁而造成了死锁，最好在finally中声明释放锁。
   **灵活度**：ReentrantLock要优于Synchronized，可以灵活控制在哪个位置加锁和解锁。

   #### 性能区别

   我们平时写代码的时候用到Java最多的锁是Synchronized，单例模式中看到的锁也是Synchronized。这是为什么呢？除了Synchronized使用方面一些，其实和ReentrantLock对比，性能也丝毫不逊色，这里面说的当然是JDK1.5以后的版本了。

   JDK1.6以前的版本没有优化，这时和ReentrantLock比肯定差很多。优化以后的Synchronized引入了包括偏向锁，轻量级锁等，这样就和ReentrantLock性能差不多太多了。

相同点：

\1. 都是用来协调多线程对共享对象、变量的访问 

\2. 都是可重入锁，同一线程可以多次获得同一个锁 

\3. 都保证了可见性和互斥性

不同点：

\1. ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁 

\2. ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的 不可用性提供了更高的灵活性 

\3. ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的 

\4. ReentrantLock 可以实现公平锁 

\5. ReentrantLock 通过 Condition 可以绑定多个条件 

\6. 底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻 

塞，采用的是乐观并发策略 

\7. Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言 

实现。 

\8. synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生； 

而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象， 

因此使用 Lock 时需要在 finally 块中释放锁。 

\9. Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时， 

等待的线程会一直等待下去，不能够响应中断。 

\10. 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 

\11. Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。

1. **volatile** **关键字的作用**

   Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他 

   线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的 

   地方，因此在读取 volatile 类型的变量时总会返回最新写入的值

   ***变量可见性*** 

   其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的 

   值对于其他线程是可以立即获取的。

   ***禁止重排序*** 

   volatile 禁止了指令重排。 

   ***比*** ***sychronized*** ***更轻量级的同步锁*** 

   在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一 

   种比 sychronized 关键字更轻量级的同步机制。volatile 适合这种场景：一个变量被多个线程共 

   享，线程直接给这个变量赋值

   ***适用场景*** 

   值得说明的是对 volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量， 

   但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。在某些场景下可以 

   代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置，只有在一些特殊的场景下，才能适用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全： 

    （1）对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean  

   flag = true）。 

   （2）该变量没有包含在具有其他变量的不变式中，也就是说，不同的 volatile 变量之间，不 

   能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile

### 数据库相关

### 计算机网络

### 设计模式

### 分布式相关

### 缓存相关

### 框架相关

