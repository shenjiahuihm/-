# 希尔排序

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。

## 1.算法步骤

1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；
2. 按增量序列个数 k，对序列进行 k 趟排序；
3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

## 2.时间复杂度

- 最优时间复杂度：根据步长序列的不同而不同
- 最坏时间复杂度：O(n2)
- 稳定性：不稳定

## 3.Java代码实现

对各个组进行插入的时候并不是先对一个组排序完再对另一个组排序，而是轮流对每一个组进行排序。

```java
public int[] shellSort(int[] list){

    int gap = 1;
    while (gap < list.length/3) {
        gap = gap * 3 + 1;
    }
    while(gap>0){
      //从下标gap开始，将每个元素都插入到对应位置(因为数组最开始gap个是每个组的第一个，已经算排好序了)
      for(int i=gap;i<=list.length-1;i++){

        // 记录要插入的数据
        int tmp = list[i];
        // 从已经排序的序列最右边的开始比较，找到比其小的数
        int j=i-gap;
        while(j>0&&tmp<list[j]){
          list[j+gap] = list[j];
          j-=gap;
        }
        list[j+gap] = tmp;
      }
      gap = (int) Math.floor(gap / 3);
    }
    return list;
  }
```

